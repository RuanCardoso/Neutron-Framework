using NeutronNetwork.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace NeutronNetwork.Helpers
{
    public class NeutronUIHelper : MonoBehaviour
    {
        /// <summary>
        /// Notifies you of removing an item from the interface.
        /// </summary>
        /// <typeparam name="T">Generic Type</typeparam>
        /// <param name="mParent">Transform parent of interface objects</param>
        /// <param name="mArray">The object that will generate the objects in the interface</param>
        /// <param name="mCacheArray">The list that stores the interface objects generated by mArray</param>
        /// <param name="mDestroy">Indicates whether to remove or destroy the interface object</param>
        /// <returns></returns>
        public bool? NotifyDestroy<T>(Transform mParent, T[] mArray, ref List<T> mCacheArray, IEqualityComparer<T> comparer, bool mDestroy = true) where T : INeutronNotify
        {
            if (mParent.childCount > mArray.Length)
            {
                var exceptList = mCacheArray.Except(mArray, comparer);
                int indexRemove = 0;
                foreach (var _ in exceptList.ToList())
                {
                    indexRemove = mCacheArray.RemoveAll(x => x.ID == _.ID);
                    foreach (Transform _child in mParent)
                    {
                        int ID = int.Parse(new string(_child.name.Where(x => char.IsNumber(x)).ToArray()));
                        if (ID == _.ID)
                        {
                            if (mDestroy) Destroy(_child.gameObject);
                            else _child.gameObject.SetActive(false);
                        }
                    }
                    //if (onNotify) onNotifyDestroy(_.ID, ((NOTIFY)new System.Diagnostics.StackFrame(1).GetMethod().GetCustomAttributes(typeof(NOTIFY), false).FirstOrDefault()).eventName);
                }
                //===========================================================================================
                return Convert.ToBoolean(indexRemove);
            }
            return null;
        }
        /// <summary>
        /// Indicates whether to remove or destroy the interface object
        /// </summary>
        /// <typeparam name="T">Generic Type</typeparam>
        /// <param name="mArray">The list that generated the objects in the interface</param>
        /// <param name="mObject">The expression that will be used to identify whether the objects are the same or not; x => x.ID == ..........</param>
        /// <returns></returns>
        public bool NotifyExist<T>(List<T> mArray, Func<T, bool> mObject)
        {
            return mArray.Any(mObject);
        }

        public void NotifyClear<T>(Transform mParent, List<T> mArray, bool destroy = true)
        {
            foreach (Transform _p in mParent)
            {
                if (destroy) Destroy(_p.gameObject);
                else _p.gameObject.SetActive(false);
                mArray.Clear();
            }
        }

        public void NotifyUpdate<T>(T notify, Transform mParent, Action<Transform, T> method) where T : INeutronNotify
        {
            foreach (Transform child in mParent.transform)
            {
                if (child.name == notify.ID.ToString())
                {
                    method.Invoke(child, notify);
                }
                else continue;
            }
        }
    }
}